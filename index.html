<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Mini Katamari Advanced</title>
<style>
body{margin:0;overflow:hidden;background:#87CEEB;}
#ui{
position:absolute;
top:10px;left:10px;
color:white;
font-family:sans-serif;
}
</style>
</head>
<body>
<div id="ui">サイズ: <span id="size">10</span> cm</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.158/build/three.min.js"></script>

<script>

//////////////////////////////////////
// 基本設定
//////////////////////////////////////

const scene=new THREE.Scene();
scene.background=new THREE.Color(0x87CEEB);

const camera=new THREE.PerspectiveCamera(75,innerWidth/innerHeight,0.1,2000);
const renderer=new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth,innerHeight);
document.body.appendChild(renderer.domElement);

scene.add(new THREE.AmbientLight(0xffffff,0.8));
const light=new THREE.DirectionalLight(0xffffff,0.8);
light.position.set(50,100,50);
scene.add(light);

//////////////////////////////////////
// 地面
//////////////////////////////////////

const ground=new THREE.Mesh(
 new THREE.PlaneGeometry(500,500),
 new THREE.MeshStandardMaterial({color:0x55aa55})
);
ground.rotation.x=-Math.PI/2;
scene.add(ground);

//////////////////////////////////////
// 塊
//////////////////////////////////////

let size=10; // cm
let radius=size/10;

const ball=new THREE.Mesh(
 new THREE.SphereGeometry(radius,32,32),
 new THREE.MeshStandardMaterial({color:0xff66cc})
);
ball.position.y=radius;
scene.add(ball);

//////////////////////////////////////
// オブジェクト生成
//////////////////////////////////////

const objects=[];

function createObject(){
 const scale=Math.random()*8+2; // cm相当
 const mesh=new THREE.Mesh(
  new THREE.BoxGeometry(scale/10,scale/10,scale/10),
  new THREE.MeshStandardMaterial({
   color:new THREE.Color(Math.random(),Math.random(),Math.random())
  })
 );

 mesh.position.set(
  (Math.random()-0.5)*400,
  scale/20,
  (Math.random()-0.5)*400
 );

 mesh.userData.size=scale;
 mesh.userData.attached=false;

 scene.add(mesh);
 objects.push(mesh);
}

for(let i=0;i<200;i++) createObject();

//////////////////////////////////////
// 操作
//////////////////////////////////////

const keys={};
document.addEventListener("keydown",e=>keys[e.key.toLowerCase()]=true);
document.addEventListener("keyup",e=>keys[e.key.toLowerCase()]=false);

//////////////////////////////////////
// カメラ制御（自由）
//////////////////////////////////////

let camYaw=0;
let camPitch=0;

document.body.addEventListener("click",()=>{
 document.body.requestPointerLock();
});

document.addEventListener("mousemove",e=>{
 if(document.pointerLockElement===document.body){
  camYaw-=e.movementX*0.002;
  camPitch-=e.movementY*0.002;
  camPitch=Math.max(-1.2,Math.min(1.2,camPitch));
 }
});

//////////////////////////////////////
// アニメーション
//////////////////////////////////////

function animate(){
 requestAnimationFrame(animate);

 let moveSpeed=0.2;

 // 王子ダッシュ
 if(keys["shift"]) moveSpeed=0.5;

 // 移動ベクトル（カメラ基準）
 const forward=new THREE.Vector3(Math.sin(camYaw),0,Math.cos(camYaw));
 const right=new THREE.Vector3(-forward.z,0,forward.x);

 let move=new THREE.Vector3();
 if(keys["w"]) move.add(forward);
 if(keys["s"]) move.sub(forward);
 if(keys["a"]) move.sub(right);
 if(keys["d"]) move.add(right);

 // 王子ターン（Qキー）
 if(keys["q"]){
  camYaw+=0.1;
 }

 if(move.length()>0){
  move.normalize().multiplyScalar(moveSpeed);
  ball.position.add(move);
 }

 //////////////////////////////////////
 // 吸収＆障害物判定
 //////////////////////////////////////

 for(let obj of objects){

  if(obj.userData.attached) continue;

  const dist=ball.position.distanceTo(obj.position);

  const objRadius=obj.userData.size/10;

  if(dist < radius + objRadius){

   if(obj.userData.size < size*1.1){

    // 吸収
    obj.userData.attached=true;

    const offset=obj.position.clone().sub(ball.position);
    ball.add(obj);
    obj.position.copy(offset);

    size+=obj.userData.size*0.2;
    radius=size/10;

    ball.scale.set(radius,radius,radius);
    ball.position.y=radius;

    document.getElementById("size").innerText=Math.floor(size);

   }else{
    // ぶつかる
    const push=ball.position.clone().sub(obj.position).normalize().multiplyScalar(0.5);
    ball.position.add(push);
   }
  }
 }

 //////////////////////////////////////
 // カメラ追従（サイズで引く）
 //////////////////////////////////////

 const camDistance=radius*3+10;

 const camX=ball.position.x+Math.sin(camYaw)*camDistance*Math.cos(camPitch);
 const camZ=ball.position.z+Math.cos(camYaw)*camDistance*Math.cos(camPitch);
 const camY=ball.position.y+Math.sin(camPitch)*camDistance+5;

 camera.position.set(camX,camY,camZ);
 camera.lookAt(ball.position);

 renderer.render(scene,camera);
}

animate();

</script>
</body>
</html>
