<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Katamari Stages</title>
<style>
body{margin:0;overflow:hidden;background:black;}
#menu{
position:absolute;top:50%;left:50%;
transform:translate(-50%,-50%);
color:white;text-align:center;font-family:sans-serif;
}
button{padding:10px 20px;margin:5px;font-size:16px;}
#ui{
position:absolute;top:10px;left:10px;
color:white;font-family:sans-serif;display:none;
}
</style>
</head>
<body>

<div id="menu">
<h1>ステージ選択</h1>
<button onclick="startGame('house')">イエ</button>
<button onclick="startGame('city')">マチ</button>
<button onclick="startGame('world')">セカイ</button>
<button onclick="startGame('earth')">チキュウ</button>
<button onclick="startGame('space')">ウチュウ</button>
</div>

<div id="ui">
サイズ: <span id="size">10</span>cm
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.158/build/three.min.js"></script>
<script>

let scene,camera,renderer,ball;
let objects=[];
let size=10,radius;
let keys={};
let yaw=0,pitch=0;

function startGame(stage){
 document.getElementById("menu").style.display="none";
 document.getElementById("ui").style.display="block";
 init(stage);
}

function init(stage){

 scene=new THREE.Scene();
 camera=new THREE.PerspectiveCamera(75,innerWidth/innerHeight,0.1,10000);

 renderer=new THREE.WebGLRenderer({antialias:true});
 renderer.setSize(innerWidth,innerHeight);
 renderer.shadowMap.enabled=true;
 document.body.appendChild(renderer.domElement);

 const light=new THREE.DirectionalLight(0xffffff,1);
 light.position.set(200,400,200);
 light.castShadow=true;
 scene.add(light);
 scene.add(new THREE.AmbientLight(0xffffff,0.4));

 size=10;
 radius=size/10;

 ball=new THREE.Mesh(
  new THREE.SphereGeometry(radius,32,32),
  new THREE.MeshStandardMaterial({color:0xff66cc})
 );
 ball.castShadow=true;
 ball.position.y=radius;
 scene.add(ball);

 createMap(stage);
 createObjects(stage);

 document.body.addEventListener("click",()=>{
  document.body.requestPointerLock();
 });

 document.addEventListener("mousemove",e=>{
  if(document.pointerLockElement===document.body){
   yaw-=e.movementX*0.002;
   pitch-=e.movementY*0.002;
   pitch=Math.max(-1.2,Math.min(1.2,pitch));
  }
 });

 document.addEventListener("keydown",e=>keys[e.key.toLowerCase()]=true);
 document.addEventListener("keyup",e=>keys[e.key.toLowerCase()]=false);

 animate();
}

//////////////////////////////////////////////////
// マップ生成
//////////////////////////////////////////////////

function createMap(stage){

 if(stage==="house"){
  scene.background=new THREE.Color(0xf5deb3);

  const floor=new THREE.Mesh(
   new THREE.PlaneGeometry(200,200),
   new THREE.MeshStandardMaterial({color:0xd2b48c})
  );
  floor.rotation.x=-Math.PI/2;
  floor.receiveShadow=true;
  scene.add(floor);

  // 壁
  createWall(0,50,100,10);
  createWall(0,-50,100,10);
  createWall(50,0,10,100);
  createWall(-50,0,10,100);
 }

 else if(stage==="city"){
  scene.background=new THREE.Color(0x87ceeb);

  const ground=new THREE.Mesh(
   new THREE.PlaneGeometry(1000,1000),
   new THREE.MeshStandardMaterial({color:0x555555})
  );
  ground.rotation.x=-Math.PI/2;
  scene.add(ground);
 }

 else if(stage==="world"){
  scene.background=new THREE.Color(0xffcc88);

  const ground=new THREE.Mesh(
   new THREE.PlaneGeometry(2000,2000),
   new THREE.MeshStandardMaterial({color:0xdeb887})
  );
  ground.rotation.x=-Math.PI/2;
  scene.add(ground);
 }

 else if(stage==="earth"){
  scene.background=new THREE.Color(0x000022);

  const earth=new THREE.Mesh(
   new THREE.SphereGeometry(500,64,64),
   new THREE.MeshStandardMaterial({color:0x2266dd})
  );
  scene.add(earth);
 }

 else if(stage==="space"){
  scene.background=new THREE.Color(0x000011);
 }

}

function createWall(x,z,w,d){
 const wall=new THREE.Mesh(
  new THREE.BoxGeometry(w,20,d),
  new THREE.MeshStandardMaterial({color:0x8b4513})
 );
 wall.position.set(x,10,z);
 wall.castShadow=true;
 wall.userData.block=true;
 scene.add(wall);
 objects.push(wall);
}

//////////////////////////////////////////////////
// オブジェクト生成
//////////////////////////////////////////////////

function createObjects(stage){

 objects=[];

 function addObject(mesh,sizeVal){
  mesh.userData.size=sizeVal;
  mesh.userData.attached=false;
  mesh.castShadow=true;
  scene.add(mesh);
  objects.push(mesh);
 }

 if(stage==="house"){
  for(let i=0;i<200;i++){
   let s=Math.random()*10+1;
   let obj=new THREE.Mesh(
    new THREE.BoxGeometry(s,s,s),
    new THREE.MeshStandardMaterial({color:0xffaaaa})
   );
   obj.position.set((Math.random()-0.5)*80,s/2,(Math.random()-0.5)*80);
   addObject(obj,s);
  }
 }

 if(stage==="city"){
  for(let i=0;i<300;i++){
   let s=Math.random()*30+5;
   let obj=new THREE.Mesh(
    new THREE.CylinderGeometry(s/4,s/4,s,8),
    new THREE.MeshStandardMaterial({color:0x228b22})
   );
   obj.position.set((Math.random()-0.5)*800,s/2,(Math.random()-0.5)*800);
   addObject(obj,s);
  }
 }

 if(stage==="world"){
  for(let i=0;i<400;i++){
   let s=Math.random()*80+20;
   let obj=new THREE.Mesh(
    new THREE.BoxGeometry(s,s,s),
    new THREE.MeshStandardMaterial({color:0x888888})
   );
   obj.position.set((Math.random()-0.5)*1500,s/2,(Math.random()-0.5)*1500);
   addObject(obj,s);
  }
 }

 if(stage==="earth"){
  for(let i=0;i<100;i++){
   let s=Math.random()*150+50;
   let obj=new THREE.Mesh(
    new THREE.SphereGeometry(s/2),
    new THREE.MeshStandardMaterial({color:0xffffff})
   );
   obj.position.set((Math.random()-0.5)*2000,s/2,(Math.random()-0.5)*2000);
   addObject(obj,s);
  }
 }

 if(stage==="space"){
  for(let i=0;i<150;i++){
   let s=Math.random()*200+50;
   let obj=new THREE.Mesh(
    new THREE.SphereGeometry(s/2),
    new THREE.MeshStandardMaterial({color:0x9999ff})
   );
   obj.position.set((Math.random()-0.5)*3000,s/2,(Math.random()-0.5)*3000);
   addObject(obj,s);
  }
 }

}

//////////////////////////////////////////////////
// アニメーション
//////////////////////////////////////////////////

function animate(){
 requestAnimationFrame(animate);

 let speed=keys["shift"]?0.6:0.3;
 let move=new THREE.Vector3();

 if(keys["w"]) move.z-=1;
 if(keys["s"]) move.z+=1;
 if(keys["a"]) move.x-=1;
 if(keys["d"]) move.x+=1;

 if(move.length()>0){
  move.normalize().multiplyScalar(speed);
  ball.position.add(move);

  ball.rotation.x+=move.z*0.2;
  ball.rotation.z-=move.x*0.2;
 }

 for(let obj of objects){

  if(obj.userData.attached) continue;

  let dist=ball.position.distanceTo(obj.position);
  let objRadius=obj.userData.size/10;

  if(dist<radius+objRadius){

   if(obj.userData.size<size*1.2){
    obj.userData.attached=true;
    let offset=obj.position.clone().sub(ball.position);
    ball.add(obj);
    obj.position.copy(offset);

    size+=obj.userData.size*0.1;
    radius=size/10;
    ball.scale.set(radius,radius,radius);
    ball.position.y=radius;
    document.getElementById("size").innerText=Math.floor(size);
   }
   else{
    // 障害物押し返し
    let push=ball.position.clone().sub(obj.position).normalize().multiplyScalar(1);
    ball.position.add(push);
   }
  }
 }

 let camDist=radius*3+30;

 camera.position.set(
  ball.position.x+Math.sin(yaw)*camDist,
  ball.position.y+camDist*0.6,
  ball.position.z+Math.cos(yaw)*camDist
 );
 camera.lookAt(ball.position);

 renderer.render(scene,camera);
}

</script>
</body>
</html>
