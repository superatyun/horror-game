<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Midwest Escape - Nightfall</title>
<style>
body{margin:0;overflow:hidden;background:black;}
#ui{
 position:absolute;top:10px;left:10px;
 color:white;font-family:sans-serif;
}
#staminaBar{
 width:200px;height:20px;background:#333;margin-top:5px;
}
#stamina{height:100%;width:100%;background:lime;}
</style>
</head>
<body>

<div id="ui">
WASD移動 / Shiftダッシュ / F長押しで振り向く
<div id="staminaBar"><div id="stamina"></div></div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.158/build/three.min.js"></script>
<script>

//////////////////////////////////////////////////
// 基本
//////////////////////////////////////////////////

const scene=new THREE.Scene();
const camera=new THREE.PerspectiveCamera(70,innerWidth/innerHeight,0.1,1000);
camera.position.set(0,1.7,0);

const renderer=new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth,innerHeight);
renderer.shadowMap.enabled=true;
document.body.appendChild(renderer.domElement);

//////////////////////////////////////////////////
// 時間経過システム
//////////////////////////////////////////////////

let time=0; // 0=夕方 1=夜

const ambient=new THREE.AmbientLight(0xffffff,0.8);
scene.add(ambient);

const sun=new THREE.DirectionalLight(0xffaa88,1);
sun.position.set(50,100,50);
scene.add(sun);

function updateDayNight(){
 time+=0.00005;
 if(time>1) time=1;

 const skyColor=new THREE.Color().lerpColors(
   new THREE.Color(0xff9966),
   new THREE.Color(0x000022),
   time
 );
 renderer.setClearColor(skyColor);

 ambient.intensity=0.8-(time*0.5);
 sun.intensity=1-(time*0.8);
}

//////////////////////////////////////////////////
// 地面
//////////////////////////////////////////////////

const ground=new THREE.Mesh(
 new THREE.PlaneGeometry(400,400),
 new THREE.MeshStandardMaterial({color:0x444444})
);
ground.rotation.x=-Math.PI/2;
scene.add(ground);

//////////////////////////////////////////////////
// 障害物管理
//////////////////////////////////////////////////

const colliders=[];

function addCollider(mesh){
 const box=new THREE.Box3().setFromObject(mesh);
 colliders.push(box);
}

//////////////////////////////////////////////////
// 建物
//////////////////////////////////////////////////

function createHouse(x,z){

 if(Math.sqrt(x*x+z*z)<15) return; // 安全地帯

 const house=new THREE.Mesh(
   new THREE.BoxGeometry(6,6,6),
   new THREE.MeshStandardMaterial({color:0xb8860b})
 );
 house.position.set(x,3,z);
 scene.add(house);
 addCollider(house);
}

for(let x=-60;x<=60;x+=12){
 for(let z=-60;z<=60;z+=12){
   if(Math.random()>0.3) createHouse(x,z);
 }
}

//////////////////////////////////////////////////
// 車
//////////////////////////////////////////////////

function createCar(x,z){
 const car=new THREE.Mesh(
   new THREE.BoxGeometry(4,2,2),
   new THREE.MeshStandardMaterial({color:0x222222})
 );
 car.position.set(x,1,z);
 scene.add(car);
 addCollider(car);
}

for(let i=0;i<8;i++){
 createCar(
   (Math.random()-0.5)*120,
   (Math.random()-0.5)*120
 );
}

//////////////////////////////////////////////////
// 敵
//////////////////////////////////////////////////

const enemy=new THREE.Mesh(
 new THREE.BoxGeometry(2,5,2),
 new THREE.MeshStandardMaterial({color:0x880000})
);
enemy.position.set(-30,2.5,-30);
scene.add(enemy);

//////////////////////////////////////////////////
// カメラ制御
//////////////////////////////////////////////////

let pitch=0,yaw=0;
let targetPitch=0,targetYaw=0;

document.addEventListener("mousemove",e=>{
 if(document.pointerLockElement===document.body){
   targetYaw-=e.movementX*0.0012;
   targetPitch-=e.movementY*0.0012;
   targetPitch=Math.max(-Math.PI/4,Math.min(Math.PI/4,targetPitch));
 }
});

document.body.addEventListener("click",()=>{
 document.body.requestPointerLock();
});

//////////////////////////////////////////////////
// 入力
//////////////////////////////////////////////////

const keys={};
let lookingBack=false;

document.addEventListener("keydown",e=>{
 const k=e.key.toLowerCase();
 keys[k]=true;
 if(k==="f") lookingBack=true;
});

document.addEventListener("keyup",e=>{
 const k=e.key.toLowerCase();
 keys[k]=false;
 if(k==="f") lookingBack=false;
});

//////////////////////////////////////////////////
// スタミナ
//////////////////////////////////////////////////

let stamina=100;
const staminaEl=document.getElementById("stamina");

//////////////////////////////////////////////////
// 移動＋衝突判定
//////////////////////////////////////////////////

function checkCollision(newPos){
 const playerBox=new THREE.Box3(
   new THREE.Vector3(newPos.x-0.5,0,newPos.z-0.5),
   new THREE.Vector3(newPos.x+0.5,2,newPos.z+0.5)
 );
 for(let box of colliders){
   if(playerBox.intersectsBox(box)) return true;
 }
 return false;
}

function move(){

 let speed=0.15;
 if(keys["shift"]&&stamina>0){
   speed=0.3;
   stamina-=0.7;
 }else stamina+=0.4;

 stamina=Math.max(0,Math.min(100,stamina));
 staminaEl.style.width=stamina+"%";
 staminaEl.style.background=stamina<30?"red":"lime";

 const forward=new THREE.Vector3(Math.sin(yaw),0,Math.cos(yaw));
 const right=new THREE.Vector3(-forward.z,0,forward.x);

 let moveVec=new THREE.Vector3();
 if(keys["w"]) moveVec.add(forward);
 if(keys["s"]) moveVec.sub(forward);
 if(keys["a"]) moveVec.sub(right);
 if(keys["d"]) moveVec.add(right);

 if(moveVec.length()>0){
   moveVec.normalize().multiplyScalar(speed);

   const newPos=camera.position.clone().add(moveVec);

   if(!checkCollision(newPos)){
     camera.position.x=newPos.x;
     camera.position.z=newPos.z;
   }
 }

 camera.position.y=1.7;
}

//////////////////////////////////////////////////
// 敵追跡
//////////////////////////////////////////////////

function updateEnemy(){
 const dx=camera.position.x-enemy.position.x;
 const dz=camera.position.z-enemy.position.z;
 const dist=Math.sqrt(dx*dx+dz*dz);

 if(dist>2){
   enemy.position.x+=dx/dist*0.05;
   enemy.position.z+=dz/dist*0.05;
 }

 enemy.lookAt(camera.position);
}

//////////////////////////////////////////////////
// アニメーション
//////////////////////////////////////////////////

function animate(){
 requestAnimationFrame(animate);

 updateDayNight();

 if(lookingBack){
   camera.rotation.set(pitch,yaw+Math.PI,0);
 }else{
   yaw+=(targetYaw-yaw)*0.15;
   pitch+=(targetPitch-pitch)*0.15;
   camera.rotation.set(pitch,yaw,0);
 }

 move();
 updateEnemy();

 renderer.render(scene,camera);
}
animate();

</script>
</body>
</html>
