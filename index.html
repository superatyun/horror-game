<!DOCTYPE html>
<html>
<head>
<title>Horror House</title>
<style>
body { margin: 0; overflow: hidden; }
#info {
  position: absolute;
  top: 10px;
  left: 10px;
  color: white;
  font-family: sans-serif;
}
</style>
</head>
<body>
<div id="info">WASD移動 / マウス視点 / Rで振り向く</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>

<script>
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87CEEB); // 青空

const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// ライト
const light = new THREE.HemisphereLight(0xffffff, 0x444444, 1);
scene.add(light);

// ===== 床（室内） =====
const floorGeo = new THREE.PlaneGeometry(40, 40);
const floorMat = new THREE.MeshStandardMaterial({ color: 0x555555 });
const floor = new THREE.Mesh(floorGeo, floorMat);
floor.rotation.x = -Math.PI / 2;
scene.add(floor);

// ===== 草原（外） =====
const grassGeo = new THREE.PlaneGeometry(200, 200, 50, 50);
grassGeo.attributes.position.array.forEach((v, i) => {
  if (i % 3 === 2) grassGeo.attributes.position.array[i] += Math.random() * 2;
});
grassGeo.computeVertexNormals();
const grassMat = new THREE.MeshStandardMaterial({ color: 0x228B22 });
const grass = new THREE.Mesh(grassGeo, grassMat);
grass.rotation.x = -Math.PI / 2;
grass.position.y = -1;
grass.position.z = -100;
scene.add(grass);

// ===== 壁 =====
const walls = [];

function createWall(x, z, w, h, d) {
  const geo = new THREE.BoxGeometry(w, h, d);
  const mat = new THREE.MeshStandardMaterial({ color: 0x888888 });
  const wall = new THREE.Mesh(geo, mat);
  wall.position.set(x, h/2, z);
  scene.add(wall);
  walls.push(wall);
}

createWall(0, -20, 40, 10, 1);
createWall(-20, 0, 1, 10, 40);
createWall(20, 0, 1, 10, 40);
createWall(0, 20, 40, 10, 1);

// ===== 2階床 =====
const secondFloor = new THREE.Mesh(
  new THREE.PlaneGeometry(30, 30),
  new THREE.MeshStandardMaterial({ color: 0x666666 })
);
secondFloor.rotation.x = -Math.PI/2;
secondFloor.position.y = 5;
scene.add(secondFloor);

// ===== 玄関ドア =====
const door = new THREE.Mesh(
  new THREE.BoxGeometry(4, 7, 0.5),
  new THREE.MeshStandardMaterial({ color: 0x442200 })
);
door.position.set(0, 3.5, -19.5);
scene.add(door);

// ===== 敵 =====
const enemy = new THREE.Group();

// 下半身
const legs = new THREE.Mesh(
  new THREE.BoxGeometry(2,3,2),
  new THREE.MeshStandardMaterial({ color: 0x880000 })
);
legs.position.y = 1.5;
enemy.add(legs);

// 胴体
const body = new THREE.Mesh(
  new THREE.BoxGeometry(2,3,1.5),
  new THREE.MeshStandardMaterial({ color: 0xaa0000 })
);
body.position.y = 4;
enemy.add(body);

// 顔
const face = new THREE.Mesh(
  new THREE.BoxGeometry(2,2,1.5),
  new THREE.MeshStandardMaterial({ color: 0xcc0000 })
);
face.position.y = 6;
enemy.add(face);

// 目
const eyeGeo = new THREE.SphereGeometry(0.3);
const eyeMat = new THREE.MeshBasicMaterial({ color: 0xffffff });

const eye1 = new THREE.Mesh(eyeGeo, eyeMat);
eye1.position.set(-0.5,6.3,0.8);
scene.add(eye1);

const eye2 = new THREE.Mesh(eyeGeo, eyeMat);
eye2.position.set(0.5,6.3,0.8);
scene.add(eye2);

enemy.position.set(10,0,10);
scene.add(enemy);

// ===== カメラ =====
camera.position.set(0, 2, 10);

// ===== 操作 =====
const keys = {};
document.addEventListener("keydown", e => keys[e.key.toLowerCase()] = true);
document.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);

// 振り向き
document.addEventListener("keydown", e => {
  if (e.key.toLowerCase() === "r") {
    camera.rotation.y += Math.PI;
  }
});

// マウス視点
document.addEventListener("mousemove", e => {
  camera.rotation.y -= e.movementX * 0.002;
  camera.rotation.x -= e.movementY * 0.002;
});

// ===== 当たり判定 =====
function checkCollision(newPos) {
  for (let wall of walls) {
    if (Math.abs(newPos.x - wall.position.x) < 2 &&
        Math.abs(newPos.z - wall.position.z) < 2) {
      return true;
    }
  }
  return false;
}

// ===== アニメーション =====
function animate() {
  requestAnimationFrame(animate);

  let newPos = camera.position.clone();

  if (keys["w"]) newPos.z -= 0.2;
  if (keys["s"]) newPos.z += 0.2;
  if (keys["a"]) newPos.x -= 0.2;
  if (keys["d"]) newPos.x += 0.2;

  if (!checkCollision(newPos)) {
    camera.position.copy(newPos);
  }

  // 敵追跡
  enemy.lookAt(camera.position);
  enemy.position.x += (camera.position.x - enemy.position.x) * 0.002;
  enemy.position.z += (camera.position.z - enemy.position.z) * 0.002;

  // ゴール判定
  if (camera.position.distanceTo(door.position) < 3) {
    alert("脱出成功！");
    location.reload();
  }

  renderer.render(scene, camera);
}

animate();
</script>
</body>
</html>
