<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>HORROR CITY ESCAPE</title>
<style>
body { margin:0; overflow:hidden; background:black; }
#info {
  position:absolute;
  top:10px;
  left:10px;
  color:white;
  font-family:sans-serif;
}
</style>
</head>
<body>
<div id="info">WASD移動 / マウス視点 / Fで振り向く / 出口を探せ</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.158/build/three.min.js"></script>

<script>
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0a0a15);

const camera = new THREE.PerspectiveCamera(75,innerWidth/innerHeight,0.1,1000);
camera.position.set(0,1.7,0);

const renderer = new THREE.WebGLRenderer();
renderer.setSize(innerWidth,innerHeight);
document.body.appendChild(renderer.domElement);

// ===== 光 =====
scene.add(new THREE.AmbientLight(0x404040,2));
const moon = new THREE.DirectionalLight(0x8888ff,1);
moon.position.set(5,10,5);
scene.add(moon);

// ===== 地面 =====
const ground = new THREE.Mesh(
  new THREE.PlaneGeometry(200,200),
  new THREE.MeshStandardMaterial({color:0x111111})
);
ground.rotation.x = -Math.PI/2;
scene.add(ground);

// ===== 建物 =====
const buildings = [];

function createBuilding(x,z,w,h,d,color){
  const mesh = new THREE.Mesh(
    new THREE.BoxGeometry(w,h,d),
    new THREE.MeshStandardMaterial({color})
  );
  mesh.position.set(x,h/2,z);
  scene.add(mesh);

  const box = new THREE.Box3().setFromObject(mesh);
  buildings.push(box);
}

// 密集住宅街
for(let x=-30;x<=30;x+=6){
  for(let z=-30;z<=30;z+=6){
    if(Math.random()>0.2){
      createBuilding(x,z,4,5,4,0x222244);
    }
  }
}

// ===== ビル =====
for(let i=0;i<5;i++){
  createBuilding(
    (Math.random()-0.5)*40,
    (Math.random()-0.5)*40,
    6,
    15,
    6,
    0x111133
  );
}

// ===== 出口 =====
const exit = new THREE.Mesh(
  new THREE.BoxGeometry(4,4,1),
  new THREE.MeshStandardMaterial({color:0x00ff00})
);
exit.position.set(45,2,0);
scene.add(exit);

// ===== 敵 =====
const enemy = new THREE.Group();

// 足
const legs = new THREE.Mesh(
  new THREE.CylinderGeometry(0.6,0.6,2),
  new THREE.MeshStandardMaterial({color:0x550000})
);
legs.position.y=1;
enemy.add(legs);

// 胴体
const body = new THREE.Mesh(
  new THREE.BoxGeometry(1.5,2,1),
  new THREE.MeshStandardMaterial({color:0x880000})
);
body.position.y=3;
enemy.add(body);

// 頭
const head = new THREE.Mesh(
  new THREE.SphereGeometry(0.8),
  new THREE.MeshStandardMaterial({color:0xaa0000})
);
head.position.y=4.5;
enemy.add(head);

// 目
const eyeGeo = new THREE.SphereGeometry(0.2);
const eyeMat = new THREE.MeshBasicMaterial({color:0xffffff});
const eye1 = new THREE.Mesh(eyeGeo,eyeMat);
eye1.position.set(-0.3,4.6,0.7);
enemy.add(eye1);
const eye2 = new THREE.Mesh(eyeGeo,eyeMat);
eye2.position.set(0.3,4.6,0.7);
enemy.add(eye2);

enemy.position.set(-20,0,-20);
scene.add(enemy);

// ===== 操作 =====
const keys = {};
document.addEventListener("keydown",e=>{
  keys[e.key.toLowerCase()]=true;
  if(e.key.toLowerCase()==="f"){
    camera.rotation.y+=Math.PI;
  }
});
document.addEventListener("keyup",e=>{
  keys[e.key.toLowerCase()]=false;
});

document.body.addEventListener("click",()=>{
  document.body.requestPointerLock();
});

let pitch=0;
let yaw=0;

document.addEventListener("mousemove",e=>{
  if(document.pointerLockElement===document.body){
    yaw-=e.movementX*0.002;
    pitch-=e.movementY*0.002;
    pitch=Math.max(-Math.PI/2,Math.min(Math.PI/2,pitch));
    camera.rotation.set(pitch,yaw,0);
  }
});

// ===== 移動 + 衝突判定 =====
function move(){
  const speed=0.15;
  const dir=new THREE.Vector3();
  camera.getWorldDirection(dir);
  dir.y=0;
  dir.normalize();

  const right=new THREE.Vector3();
  right.crossVectors(dir,camera.up);

  let nextPos=camera.position.clone();

  if(keys["w"]) nextPos.addScaledVector(dir,speed);
  if(keys["s"]) nextPos.addScaledVector(dir,-speed);
  if(keys["a"]) nextPos.addScaledVector(right,-speed);
  if(keys["d"]) nextPos.addScaledVector(right,speed);

  const playerBox=new THREE.Box3().setFromCenterAndSize(
    new THREE.Vector3(nextPos.x,1.7,nextPos.z),
    new THREE.Vector3(1,3,1)
  );

  let collision=false;
  for(let box of buildings){
    if(playerBox.intersectsBox(box)){
      collision=true;
      break;
    }
  }

  if(!collision){
    camera.position.x=nextPos.x;
    camera.position.z=nextPos.z;
  }

  camera.position.y=1.7; // めり込み防止
}

// ===== 敵追跡 =====
function updateEnemy(){
  const dx=camera.position.x-enemy.position.x;
  const dz=camera.position.z-enemy.position.z;
  const dist=Math.sqrt(dx*dx+dz*dz);

  if(dist>1){
    enemy.position.x+=dx/dist*0.05;
    enemy.position.z+=dz/dist*0.05;
  }else{
    alert("捕まった...");
    location.reload();
  }

  enemy.lookAt(camera.position);
}

// ===== 脱出判定 =====
function checkExit(){
  if(camera.position.distanceTo(exit.position)<3){
    alert("脱出成功！");
    location.reload();
  }
}

function animate(){
  requestAnimationFrame(animate);
  move();
  updateEnemy();
  checkExit();
  renderer.render(scene,camera);
}
animate();
</script>
</body>
</html>
